# DataStore with Form Data - Usage Guide

This guide explains how to use the DataStore to store and retrieve test data generated by `TestDataGenerator` methods in your form filling operations.

## Overview

The DataStore integration with `fillMinimalForm` allows you to:

- Automatically store generated test data for later use
- Share data between different test steps
- Retrieve specific form fields for assertions
- Maintain data consistency across test operations

## Basic Usage

### 1. Automatic Storage with fillMinimalForm

The [`FormsService.fillMinimalForm()`](../steps/components/Forms.ts:31) method now automatically stores all generated data in the DataStore:

```typescript
import { FormsService } from '@steps/components/Forms';
import { dataStore } from '@framework/utils/DataStore';

// Fill the form - data is automatically stored
const formsService = new FormsService(page);
const usedFormData = await formsService.fillMinimalForm();

// Retrieve stored data later
const companyName = dataStore.getValue<string>('formData.companyName');
const email = dataStore.getValue<string>('formData.email');
const firstName = dataStore.getValue<string>('formData.contactForename');
const lastName = dataStore.getValue<string>('formData.contactSurname');
```

### 2. Storage Keys

The following keys are automatically created when using `fillMinimalForm`:

| Key                        | Description               | Example Value                               |
| -------------------------- | ------------------------- | ------------------------------------------- |
| `formData.contactForename` | Generated first name      | "John"                                      |
| `formData.contactSurname`  | Generated last name       | "Smith"                                     |
| `formData.companyName`     | Generated company name    | "Tech Solutions Ltd"                        |
| `formData.email`           | Generated email           | "john.smith@example.com"                    |
| `formData.phone`           | Generated phone number    | "07123456789"                               |
| `formData.date`            | Resolved date             | "15/03/2024"                                |
| `formData.activePlanLabel` | Selected plan label       | "Premium Plan"                              |
| `formData.complete`        | Complete form data object | `{ companyName: "...", email: "...", ... }` |
| `formData.searchData`      | Last search data used     | `{ forename: "...", surname: "...", ... }`  |

### 2. Automatic Search with searchMinimalForm

The [`FormsService.searchMinimalForm()`](../steps/components/Forms.ts:109) method automatically fills search fields using stored data:

```typescript
import { FormsService } from '@steps/components/Forms';
import { dataStore } from '@framework/utils/DataStore';

// First, create a client (data gets stored automatically)
const formsService = new FormsService(page);
await formsService.fillMinimalForm();

// Later, search using the stored data
await page.goto('/search-page');
const searchData = await formsService.searchMinimalForm();
// This automatically fills: searchForename, searchSurname, searchCompany, searchEmail

// Search with custom overrides
const customSearchData = await formsService.searchMinimalForm({
  forename: 'CustomName', // Override stored first name
  // surname, company, email will use stored values
});

// Search using data from a different prefix
const searchData = await formsService.searchMinimalForm({}, 'client1');
```

## Advanced Usage with FormDataHelper

### 3. Using FormDataHelper

The [`FormDataHelper`](../../framework/src/utils/FormDataHelper.ts) provides additional utilities for managing form data:

```typescript
import { FormDataHelper } from '@framework/utils/FormDataHelper';

// Generate and store data with custom prefix
const userData = FormDataHelper.generateAndStore('user1');

// Retrieve specific fields
const firstName = FormDataHelper.getField('firstName', 'user1');
const email = FormDataHelper.getField('email', 'user1');

// Check if data exists
if (FormDataHelper.hasStoredData('user1')) {
  const completeData = FormDataHelper.getStoredData('user1');
  console.log('Stored user data:', completeData);
}

// Generate with custom overrides
const customData = FormDataHelper.generateWithOverrides(
  {
    firstName: 'Alice',
    companyName: 'Custom Corp',
  },
  'customUser'
);
```

## Practical Examples

### Example 1: Create and Search Workflow (Using searchMinimalForm)

```typescript
test('Create client and search for it', async ({ page }) => {
  // Step 1: Create a client
  await page.goto('/create-client');
  const formsService = new FormsService(page);

  // Fill form and store data automatically
  const createdData = await formsService.fillMinimalForm();
  await page.click('[data-testid="submit-button"]');

  // Step 2: Search for the created client
  await page.goto('/search-clients');

  // Use stored data to fill search fields automatically
  const searchData = await formsService.searchMinimalForm();
  await page.click('[data-testid="search-button"]');

  // Verify client appears in results
  await expect(page.locator(`text=${searchData.company}`)).toBeVisible();
  await expect(page.locator(`text=${searchData.email}`)).toBeVisible();

  // Verify search data matches created data
  expect(searchData.forename).toBe(createdData.contactForename);
  expect(searchData.surname).toBe(createdData.contactSurname);
});
```

### Example 1b: Create and Search Workflow (Manual approach)

```typescript
test('Create client and search for it', async ({ page }) => {
  // Step 1: Create a client
  await page.goto('/create-client');
  const formsService = new FormsService(page);

  // Fill form and store data automatically
  await formsService.fillMinimalForm();
  await page.click('[data-testid="submit-button"]');

  // Step 2: Search for the created client
  await page.goto('/search-clients');

  // Use stored data for search
  const companyName = dataStore.getValue<string>('formData.companyName');
  const email = dataStore.getValue<string>('formData.email');

  await page.fill('[data-testid="search-company"]', companyName);
  await page.click('[data-testid="search-button"]');

  // Verify client appears in results
  await expect(page.locator(`text=${companyName}`)).toBeVisible();
  await expect(page.locator(`text=${email}`)).toBeVisible();
});
```

### Example 2: Search with Custom Overrides

```typescript
test('Search with partial custom data', async ({ page }) => {
  // Create a client first
  await page.goto('/create-client');
  const formsService = new FormsService(page);
  await formsService.fillMinimalForm();

  // Search with some custom data, some stored data
  await page.goto('/search-clients');
  const searchData = await formsService.searchMinimalForm({
    forename: 'CustomFirstName', // Override stored first name
    company: 'Custom Corp Ltd', // Override stored company
    // surname and email will use stored values
  });

  await page.click('[data-testid="search-button"]');

  expect(searchData.forename).toBe('CustomFirstName');
  expect(searchData.company).toBe('Custom Corp Ltd');
  expect(searchData.surname).toBeTruthy(); // Uses stored value
  expect(searchData.email).toBeTruthy(); // Uses stored value
});
```

### Example 3: Multiple Form Instances

```typescript
test('Handle multiple clients', async ({ page }) => {
  // Generate data for different clients
  const client1Data = FormDataHelper.generateAndStore('client1');
  const client2Data = FormDataHelper.generateAndStore('client2');

  // Create first client
  await page.goto('/create-client');
  const formsService = new FormsService(page);

  await formsService.fillMinimalForm({
    companyName: client1Data.companyName,
    contactForename: client1Data.firstName,
    contactSurname: client1Data.lastName,
    email: client1Data.email,
  });

  // Create second client with different data
  await formsService.fillMinimalForm({
    companyName: client2Data.companyName,
    contactForename: client2Data.firstName,
    contactSurname: client2Data.lastName,
    email: client2Data.email,
  });

  // Later, retrieve specific client data
  const client1Email = FormDataHelper.getField('email', 'client1');
  const client2Email = FormDataHelper.getField('email', 'client2');
});
```

### Example 4: Using Different Data Prefixes

```typescript
test('Handle multiple clients with different prefixes', async ({ page }) => {
  const formsService = new FormsService(page);

  // Create first client
  await page.goto('/create-client');
  const client1Data = await formsService.fillMinimalForm();

  // Store client1 data with custom prefix
  dataStore.setValue('client1.contactForename', client1Data.contactForename);
  dataStore.setValue('client1.contactSurname', client1Data.contactSurname);
  dataStore.setValue('client1.companyName', client1Data.companyName);
  dataStore.setValue('client1.email', client1Data.email);

  // Create second client (uses default 'formData' prefix)
  const client2Data = await formsService.fillMinimalForm();

  // Search using client1 data
  await page.goto('/search-clients');
  const searchData1 = await formsService.searchMinimalForm({}, 'client1');

  // Search using client2 data (default prefix)
  const searchData2 = await formsService.searchMinimalForm();

  expect(searchData1.forename).toBe(client1Data.contactForename);
  expect(searchData2.forename).toBe(client2Data.contactForename);
});
```

### Example 5: Custom Data with Fallback

```typescript
test('Use custom data with generated fallbacks', async ({ page }) => {
  await page.goto('/create-client');
  const formsService = new FormsService(page);

  // Provide some custom data, let others be generated
  const usedData = await formsService.fillMinimalForm({
    companyName: 'My Custom Company',
    contactForename: 'Alice',
    // lastName, email, phone will be generated
  });

  // The stored data will contain both custom and generated values
  const storedData = dataStore.getValue('formData.complete');

  expect(storedData.companyName).toBe('My Custom Company');
  expect(storedData.contactForename).toBe('Alice');
  expect(storedData.contactSurname).toBeTruthy(); // Generated
  expect(storedData.email).toContain('alice'); // Generated based on first name
});
```

## SearchMinimalForm Method Details

### Method Signature

```typescript
async searchMinimalForm(data: SearchFormData = {}, dataPrefix: string = 'formData')
```

### Parameters

- `data` (optional): Override specific search fields
  - `forename?: string` - Override stored contact forename
  - `surname?: string` - Override stored contact surname
  - `company?: string` - Override stored company name
  - `email?: string` - Override stored email
- `dataPrefix` (optional): DataStore prefix to retrieve data from (default: 'formData')

### Return Value

Returns an object with the actual values used for searching:

```typescript
{
  forename: string | undefined,
  surname: string | undefined,
  company: string | undefined,
  email: string | undefined
}
```

### Behavior

1. Retrieves stored data from DataStore using the specified prefix
2. Applies any provided overrides
3. Fills only the search fields that have values (skips undefined/null values)
4. Stores the search data used in `${dataPrefix}.searchData`
5. Returns the actual values used for searching

## Data Management

### Clearing Data

```typescript
// Clear all DataStore data
dataStore.clear();

// Remove specific keys
dataStore.removeValue('formData.companyName');

// Clear specific FormDataHelper data
FormDataHelper.clearStoredData('user1');
```

### Checking Data Existence

```typescript
// Check if key exists
if (dataStore.hasKey('formData.email')) {
  const email = dataStore.getValue<string>('formData.email');
}

// Check FormDataHelper data
if (FormDataHelper.hasStoredData('user1')) {
  const userData = FormDataHelper.getStoredData('user1');
}
```

## Best Practices

1. **Use Descriptive Prefixes**: When storing multiple sets of data, use descriptive prefixes:

   ```typescript
   FormDataHelper.generateAndStore('primaryContact');
   FormDataHelper.generateAndStore('billingContact');
   FormDataHelper.generateAndStore('technicalContact');
   ```

2. **Clear Data Between Tests**: Use `beforeEach` hooks to ensure clean state:

   ```typescript
   test.beforeEach(async () => {
     dataStore.clear();
   });
   ```

3. **Type Safety**: Use TypeScript types when retrieving data:

   ```typescript
   const email = dataStore.getValue<string>('formData.email');
   const formData = dataStore.getValue<MinimalFormData>('formData.complete');
   ```

4. **Consistent Naming**: Use consistent naming conventions for storage keys to avoid conflicts.

## Integration with Existing Code

The DataStore integration is backward compatible. Existing code using `fillMinimalForm` will continue to work unchanged, but now also benefits from automatic data storage.

## Troubleshooting

### Common Issues

1. **Data Not Found**: Ensure you're using the correct key names and prefixes
2. **Type Errors**: Use proper TypeScript types when retrieving data
3. **Data Persistence**: Remember that DataStore data only persists for the duration of the test run

### Debugging

```typescript
// Check all stored keys
console.log('All stored keys:', dataStore.getKeys());

// Check DataStore size
console.log('DataStore size:', dataStore.size());

// Log specific data
console.log('Form data:', dataStore.getValue('formData.complete'));
```
